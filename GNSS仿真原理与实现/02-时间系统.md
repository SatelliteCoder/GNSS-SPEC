<div align="center">
    <a name="Top"></a>
	<h1>导航算法常用的时间系统</h1>
    <img alt="Static Badge" src="https://img.shields.io/badge/QQ-1482275402-red">
    <img alt="Static Badge" src="https://img.shields.io/badge/%E5%BE%AE%E4%BF%A1-lizhengxiao99-green">
    <img alt="Static Badge" src="https://img.shields.io/badge/Email-dauger%40126.com-brown">
    <a href="https://blog.csdn.net/daoge2666/"><img src="https://img.shields.io/badge/CSDN-论坛-c32136" /></a>
    <a href="https://www.zhihu.com/people/dao-ge-92-60/"><img src="https://img.shields.io/badge/Zhihu-知乎-blue" /></a>
    <img src="https://komarev.com/ghpvc/?username=LiZhengXiao99&label=Views&color=0e75b6&style=flat" alt="访问量统计" />
</div>

<br/>

[TOC]

## 1. 概述

时间系统是导航定位的基础，任何导航算法都离不开精确的时间测量和同步。全球导航卫星系统（GNSS）通过测量信号传播时间来计算距离，因此时间系统的精确度和稳定性直接决定了定位精度。

一个完整的时间系统包含两个基本要素：
- **时间起点（历元）**：时间计算的起始参考点
- **时间间隔尺度**：时间单位的基本长度

## 2. 基本时间系统

### 2.1 恒星时（Sidereal Time, ST）

**定义**：以春分点为基本参考点，由春分点周日视运动确定的时间称为恒星时。

**特点**：
- 基于地球自转周期
- 1恒星日 = 地球相对于春分点自转360°所需时间
- 1恒星日 ≈ 23小时56分4.09秒（平太阳时）
- 主要用于天文观测和卫星轨道计算

### 2.2 太阳时

#### 2.2.1 真太阳时

**定义**：以真太阳作为基本参考点，由其周日视运动确定的时间。

**特点**：
- 基于实际太阳位置
- 由于地球公转轨道是椭圆且存在黄赤交角，真太阳时不均匀

#### 2.2.2 平太阳时

**定义**：为了解决真太阳时不均匀的问题，引入虚拟的"平太阳"概念，平太阳在赤道上以均匀速度运行，其速度等于真太阳周年运动的平均速度。

**特点**：
- 平太阳连续经过同一子午圈的时间称为一个平太阳日
- 1平太阳日分为24平太阳时
- 日常使用的时间系统基于平太阳时

### 2.3 世界时（Universal Time, UT）

**定义**：以本初子午线（0°经线）的平太阳时为基准的时间系统。

**分类**：
- **UT0**：直接通过天文观测得到的世界时
- **UT1**：对UT0进行极移改正后的世界时，反映地球自转的真实角度
- **UT2**：对UT1进行地球自转季节性变化改正后的世界时

**特点**：
- 基于地球自转
- 不均匀且逐渐变慢（每天约增加2-3毫秒）
- UT1是天文学和大地测量学中的重要参考

### 2.4 原子时（Atomic Time, AT）

**定义**：以原子谐振信号周期为标准，并对它进行连续计数的时标。

**特点**：
- 基于铯-133原子基态两个超精细能级间跃迁辐射的9,192,631,770周所持续的时间为1秒
- 极其稳定和精确
- 是现代时间系统的基础

### 2.5 国际原子时（International Atomic Time, TAI）

**定义**：由国际计量局(BIPM)根据全球多个实验室的原子钟数据加权平均计算保持的原子时。

**历史**：
- 起点：1958年1月1日0时0分0秒世界时(UT)的瞬间
- 事后发现，在该瞬间TAI与UT的时刻之差为0.0039秒

**特点**：
- 连续均匀的时间尺度
- 不与任何天文现象直接关联
- 为全球提供高精度的时间参考

### 2.6 协调世界时（Coordinated Universal Time, UTC）

**定义**：以原子秒长为计量单位，在时刻上尽量接近世界时的时间系统。

**特点**：
- 时间尺度基于TAI（与TAI相差整数秒）
- 时刻与UT1相差不超过0.9秒
- 通过闰秒（跳秒）调整保持与UT1接近
- 民用时间的基础，也是计算机系统默认时间

**闰秒机制**：
当UTC与UT1相差将超过0.9秒时，在6月30日或12月31日的最后一分钟增加或减少1秒。
- 正闰秒：23:59:60 → 00:00:00
- 负闰秒：23:59:58 → 00:00:00（理论上可能，至今未发生）

## 3. GNSS时间系统

### 3.1 GPS时间（GPST）

**定义**：由GPS星载原子钟和地面监控站原子钟维持的时间系统。

**特点**：
- 起点：1980年1月6日0时0分0秒（UTC）
- 与TAI保持固定偏差：GPST = TAI - 19秒
- 不含闰秒，连续均匀
- 通过导航电文发布与UTC的偏移信息

**时间表示**：
- 周数（Week Number, WN）：从1980年1月6日开始计算
- 周内秒（Time of Week, TOW）：从每周周六/周日子夜开始起算的秒数

### 3.2 北斗时间（BDT）

**定义**：由中国北斗卫星导航系统保持的时间系统。

**特点**：
- 起点：2006年1月1日0时0分0秒（UTC）
- 与UTC保持固定偏差：BDT = UTC - 跳秒累计（截至2023年为-18秒）
- 与GPST关系：BDT = GPST - 14秒（基本恒定）
- 不含闰秒，连续均匀

### 3.3 GLONASS时间（GLST）

**定义**：由GLONASS系统保持的时间系统。

**特点**：
- 与UTC(SU)保持同步（莫斯科时间）
- 包含闰秒调整
- 与UTC存在3小时时差：GLST = UTC(SU) = UTC + 3小时

### 3.4 Galileo时间（GST）

**定义**：由Galileo卫星导航系统保持的时间系统。

**特点**：
- 起点：1999年8月22日0时0分0秒（UTC）
- 与GPST初始同步，后期独立保持
- 通过导航电文发布与GPST和UTC的偏移信息

## 4. 时间表示与转换

### 4.1 儒略日（Julian Day, JD）

**定义**：从公元前4713年1月1日世界时12:00开始连续计算的天数。

**特点**：
- 连续计数，无年月日概念
- 适用于长时间跨度的科学计算
- 小数点后表示一天中的小数部分

**计算公式**：
对于公历日期（年Y、月M、日D），儒略日计算公式为：
```
JD = ⌊365.25Y⌋ + ⌊30.6001(M+1)⌋ + D + 1720981.5
```
其中，如果M≤2，则Y=Y-1，M=M+12

### 4.2 简化儒略日（Modified Julian Day, MJD）

**定义**：MJD = JD - 2400000.5

**特点**：
- 起点：1858年11月17日世界时0时
- 减小了JD的数值大小，更方便计算
- 常用于航天和卫星领域

### 4.3 年积日（Day of Year, DOY）

**定义**：一年中的第几天，取值范围1-365（平年）或1-366（闰年）。

**应用**：
- GNSS观测文件命名（如RINEX格式）
- 简化日期计算

**闰年判断**：
年份满足以下条件之一即为闰年：
1. 能被4整除但不能被100整除
2. 能被400整除

### 4.4 周内时间表示

**周内秒（Second of Week, SOW）**：
- 一周中的秒数，取值范围0-604799
- GNSS系统常用时间表示方式

**周内时（Hour of Week, HOW）**：
- 一周中的小时数，取值范围0-167
- GPS导航电文中用于表示时间

**天内秒（Second of Day, SOD）**：
- 一天中的秒数，取值范围0-86399
- 常用于数据记录和处理

## 5. 时间系统转换

### 5.1 时间系统关系

主要时间系统之间的关系如下：
```
TAI = UTC + ΔAT (ΔAT为累计闰秒数)
GPST = TAI - 19秒
BDT = TAI - 33秒 (截至2023年)
GST = TAI - 19秒 (初始与GPST一致)
```

### 5.2 实用转换公式

**GPST与UTC转换**：
```
GPST = UTC + ΔUTC
```
其中ΔUTC为从1980年1月6日至今的累计闰秒数（截至2023年为18秒）。

**儒略日与日历日期转换**：
```c
// 从儒略日计算日历日期
void jd_to_cal(double jd, int *year, int *month, int *day, int *hour, int *minute, double *second) {
    double F = jd + 0.5;
    double Z = floor(F);
    double A = Z;
    
    if (Z >= 2299161) {
        int alpha = floor((Z - 1867216.25) / 36524.25);
        A = Z + 1 + alpha - floor(alpha / 4);
    }
    
    double B = A + 1524;
    int C = floor((B - 122.1) / 365.25);
    int D = floor(365.25 * C);
    int E = floor((B - D) / 30.6001);
    
    *day = B - D - floor(30.6001 * E);
    *month = (E < 14) ? E - 1 : E - 13;
    *year = (*month > 2) ? C - 4716 : C - 4715;
    
    double time = F - Z;
    *hour = floor(time * 24);
    *minute = floor((time * 24 - *hour) * 60);
    *second = ((time * 24 - *hour) * 60 - *minute) * 60;
}
```

**GPS周与日历日期转换**：
```c
// 计算指定日期对应的GPS周和周内秒
void date_to_gps(int year, int month, int day, int hour, int minute, double second, 
                 int *gps_week, double *gps_sow) {
    // 计算儒略日
    double jd = cal_to_jd(year, month, day, hour, minute, second);
    
    // GPS起始时间的儒略日(1980年1月6日0时)
    double jd_gps0 = cal_to_jd(1980, 1, 6, 0, 0, 0.0);
    
    // 计算相差天数
    double days = jd - jd_gps0;
    
    // 计算GPS周和周内秒
    *gps_week = floor(days / 7);
    *gps_sow = fmod(days, 7) * 86400.0;
}
```

## 6. 编程实现注意事项

### 6.1 时间处理库

在实际编程中，推荐使用专业的时间处理库：
- C/C++：`<chrono>`库（C++11及以上）
- Python：`datetime`, `pytz`, `astropy.time`库
- MATLAB：`datetime`和`duration`数据类型

### 6.2 精度问题

- 使用高精度数据类型（如double）存储时间值
- 避免浮点数精度损失，特别是对于长时间跨度计算
- 使用专业算法进行日历计算

### 6.3 时区处理

- 所有导航计算通常使用UTC时间
- 在显示结果时再转换为本地时间
- 注意夏令时的影响

### 6.4 闰秒处理

```c
// 闰秒表（截至2023年）
static struct {
    int year, month, day;
    double tai_utc;
} leap_seconds[] = {
    {2017, 1, 1, 37.0},
    {2015, 7, 1, 36.0},
    {2012, 7, 1, 35.0},
    {2009, 1, 1, 34.0},
    {2006, 1, 1, 33.0},
    {1999, 1, 1, 32.0},
    {1997, 7, 1, 31.0},
    {1996, 1, 1, 30.0},
    {1994, 7, 1, 29.0},
    {1993, 7, 1, 28.0},
    {1992, 7, 1, 27.0},
    {1991, 1, 1, 26.0},
    {1990, 1, 1, 25.0},
    {1988, 1, 1, 24.0},
    {1985, 7, 1, 23.0},
    {1983, 7, 1, 22.0},
    {1982, 7, 1, 21.0},
    {1981, 7, 1, 20.0},
    {0, 0, 0, 19.0} // 默认值（1980年1月1日前）
};

// 获取指定UTC时间对应的TAI-UTC值
double get_tai_utc(double utc_jd) {
    for (int i = 0; leap_seconds[i].year != 0; i++) {
        double ls_jd = cal_to_jd(leap_seconds[i].year, 
                                leap_seconds[i].month, 
                                leap_seconds[i].day, 
                                0, 0, 0.0);
        if (utc_jd >= ls_jd) {
            return leap_seconds[i].tai_utc;
        }
    }
    return leap_seconds[i].tai_utc; // 返回默认值
}
```

## 7. 总结

时间系统是导航算法的基石，理解各种时间系统的特点、关系和转换方法对于开发高精度导航定位应用至关重要。在实际应用中应注意：

1. 明确使用的时间系统（UTC、GPST、BDT等）
2. 正确处理时间系统之间的转换
3. 考虑闰秒和时区的影响
4. 使用高精度时间处理和计算方法
5. 定期更新闰秒表等时间参数

通过正确理解和处理时间系统，可以确保导航算法的精度和可靠性，为各种应用提供准确的定位和时间服务。

<p align="center">
    <sub>更新时间：2023年11月 | </sub>
    <a href="#Top">返回顶部</a>
</p>
