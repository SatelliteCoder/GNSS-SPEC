<p align="center">
  <img src="https://img.icons8.com/dusk/64/artificial-satellite.png" alt="卫星图标" width="80"/>
  <br>
  <strong>GNSS 卫星位置计算</strong>
</p>
<h1 align="center">
  📡 🛰️ 🗺️
  <br>
  信号仿真综合指南
</h1>

<p align="center">
  <img src="https://img.shields.io/badge/状态-维护中-brightgreen.svg" alt="状态"/>
  <img src="https://img.shields.io/badge/领域-GNSS%20仿真-blue.svg" alt="领域"/>
  <img src="https://img.shields.io/badge/难度-进阶-orange.svg" alt="难度"/>
  <img src="https://img.shields.io/badge/语言-Matlab%20|%20Python%20|%20C++-yellowgreen.svg" alt="语言"/>
</p>

---

## 📖 目录

- [📖 目录](#-目录)
- [🚀 概述](#-概述)
- [📊 输入：广播星历参数](#-输入广播星历参数)
- [⚙️ 核心计算步骤](#️-核心计算步骤)
  - [步骤 1: 计算时间偏移量 `t_k`](#步骤-1-计算时间偏移量-t_k)
  - [步骤 2: 计算校正后的平均角速度 `n`](#步骤-2-计算校正后的平均角速度-n)
  - [步骤 3: 计算平近点角 `M_k`](#步骤-3-计算平近点角-m_k)
  - [步骤 4: 求解偏近点角 `E_k` (迭代法)](#步骤-4-求解偏近点角-e_k-迭代法)
  - [步骤 5: 计算真近点角 `ν_k`](#步骤-5-计算真近点角-ν_k)
  - [步骤 6: 计算升交距角 `Φ_k`](#步骤-6-计算升交距角-φ_k)
  - [步骤 7: 应用摄动修正](#步骤-7-应用摄动修正)
  - [步骤 8: 计算轨道平面内的位置](#步骤-8-计算轨道平面内的位置)
  - [步骤 9: 转换到 ECEF 坐标系 `(X, Y, Z)`](#步骤-9-转换到-ecef-坐标系-x-y-z)
- [🧪 代码示例 (Python)](#-代码示例-python)
- [⚠️ 重要注意事项](#️-重要注意事项)
- [🔚 结论](#-结论)
- [📚 参考资料](#-参考资料)

---

## 🚀 概述

本文档详细介绍了在特定时间 `t` 下，计算 GNSS 卫星在地心地固 (ECEF) 坐标系中精确位置的算法。该位置 `(X_s, Y_s, Z_s)` 是以下方面的基础：

- **📡 仿真 GNSS 射频信号：** 生成正确的码相位和多普勒频移。
- **🧭 接收机测试与验证：** 为定位算法提供“地面真值”。
- **🎯 高保真仿真：** 基于精确的几何关系，模拟大气延迟和多路径等效应对信号的影响。

该计算将一组**开普勒轨道参数**和**摄动修正项**（由卫星导航电文广播）转换为三维直角坐标。

---

## 📊 输入：广播星历参数

计算完全依赖于每颗卫星的**广播星历**数据集。一个典型的数据集包含 16 个参数。下表描述了这些参数及其常用符号和单位。

| 参数 (常用名称) | 描述 | 符号 | 单位 |
| :--- | :--- | :--- | :--- |
| `sqrtA` | 轨道长半轴的平方根 | $\sqrt{A}$ | $\sqrt{m}$ |
| `e` | 轨道偏心率 | $e$ | 无量纲 |
| `i0` | 参考时刻的轨道倾角 | $i_0$ | 半圆 🫓 |
| `Omega0` | 参考时刻的升交点赤经 | $\Omega_0$ | 半圆 🫓 |
| `omega` | 近地点角距 | $\omega$ | 半圆 🫓 |
| `M0` | 参考时刻的平近点角 | $M_0$ | 半圆 🫓 |
| `Delta_n` | 平均运动角速度与计算值的差 | $\Delta n$ | 半圆/秒 |
| `IDOT` | 轨道倾角变化率 | $\dot{i}$ | 半圆/秒 |
| `OmegaDot` | 升交点赤经变化率 | $\dot{\Omega}$ | 半圆/秒 |
| `Cuc`, `Cus` | 升交距角余弦/正弦调和修正振幅 | $C_{uc}$, $C_{us}$ | 弧度 |
| `Crc`, `Crs` | 轨道半径余弦/正弦调和修正振幅 | $C_{rc}$, $C_{rs}$ | 米 |
| `Cic`, `Cis` | 轨道倾角余弦/正弦调和修正振幅 | $C_{ic}$, $C_{is}$ | 弧度 |
| `toe` | **星历数据参考时间** | $t_{oe}$ | 秒 |
| `IODE` | 星历数据期龄 | | |

**🛑 关键提示：** 导航电文中的角度通常以**半圆**为单位。在三角函数中使用时，**必须**将其转换为弧度：`弧度 = 半圆 * π`。

---

## ⚙️ 核心计算步骤

以下步骤计算在所需的 GNSS 系统时间 `t`（例如 GPS 时）下的卫星位置。

### 步骤 1: 计算时间偏移量 `t_k`

首先，计算相对于星历参考时间 `t_oe` 的时间差。注意处理周内秒翻转。

```python
t_k = t - t_oe

# 如果 t_k 大于 302,400 秒（半周），减去 604,800
# 如果 t_k 小于 -302,400 秒，加上 604,800
if t_k > 302400:
    t_k -= 604800
elif t_k < -302400:
    t_k += 604800
```

### 步骤 2: 计算校正后的平均角速度 `n`

计算理论平均角速度 `n0`，然后用星历中的 `Delta_n` 参数对其进行校正。

```python
GM = 3.9860050e14  # GPS 所用的地球引力常数 (m³/s²)
A = (sqrtA)**2     # 轨道长半轴 (m)
n0 = math.sqrt(GM / A**3) # 理论平均角速度 (rad/s)
n = n0 + Delta_n   # 校正后的平均角速度 (rad/s)
```

### 步骤 3: 计算平近点角 `M_k`

平近点角 `M_k` 在 `t_k` 时刻的值由参考值 `M0` 线性传播而来。

```python
M_k = M0 + n * t_k  # (rad)
```

### 步骤 4: 求解偏近点角 `E_k` (迭代法)

使用牛顿-拉弗森法求解开普勒方程 `M_k = E_k - e * sin(E_k)`，得到偏近点角 `E_k`。初始猜测值通常设为 `E_k = M_k`。

```python
E_k = M_k  # 初始猜测值
delta_E = 1
iteration_count = 0
max_iterations = 10
tolerance = 1e-12

while abs(delta_E) > tolerance and iteration_count < max_iterations:
    delta_M = M_k - (E_k - e * math.sin(E_k))
    delta_E = delta_M / (1 - e * math.cos(E_k))
    E_k += delta_E
    iteration_count += 1
```

### 步骤 5: 计算真近点角 `ν_k`

根据偏近点角和偏心率计算真近点角。使用 `atan2` 函数以确保象限正确。

```python
sin_nu_k = (math.sqrt(1 - e**2) * math.sin(E_k)) / (1 - e * math.cos(E_k))
cos_nu_k = (math.cos(E_k) - e) / (1 - e * math.cos(E_k))
nu_k = math.atan2(sin_nu_k, cos_nu_k) # 真近点角 (rad)
```

### 步骤 6: 计算升交距角 `Φ_k`

将真近点角与近地点角距相加。

```python
Phi_k = nu_k + omega # 升交距角 (rad)
```

### 步骤 7: 应用摄动修正

对升交距角、轨道半径和轨道倾角施加二阶谐波摄动修正。

```python
# 摄动修正
delta_u_k = Cus * math.sin(2 * Phi_k) + Cuc * math.cos(2 * Phi_k) # 升交距角修正
delta_r_k = Crs * math.sin(2 * Phi_k) + Crc * math.cos(2 * Phi_k) # 轨道半径修正
delta_i_k = Cis * math.sin(2 * Phi_k) + Cic * math.cos(2 * Phi_k) # 轨道倾角修正

# 应用修正
u_k = Phi_k + delta_u_k # 修正后的升交距角
r_k = A * (1 - e * math.cos(E_k)) + delta_r_k # 修正后的轨道半径
i_k = i0 + IDOT * t_k + delta_i_k # 修正后的轨道倾角
```

### 步骤 8: 计算轨道平面内的位置

计算卫星在其轨道平面内的二维位置。

```python
x_k_prime = r_k * math.cos(u_k) # 在轨道平面内的 X 坐标
y_k_prime = r_k * math.sin(u_k) # 在轨道平面内的 Y 坐标
```

### 步骤 9: 转换到 ECEF 坐标系 `(X, Y, Z)`

通过考虑修正后的轨道倾角 `i_k` 和升交点赤经 `Omega_k`，将轨道平面内的坐标转换到 ECEF 坐标系。

```python
# 计算修正后的升交点赤经
OmegaDot_e = 7.2921151467e-5  # 地球自转角速度 (rad/s)
Omega_k = Omega0 + (OmegaDot - OmegaDot_e) * t_k - OmegaDot_e * t_oe

# 执行 3D 旋转（轨道平面 -> ECEF）
X = x_k_prime * math.cos(Omega_k) - y_k_prime * math.cos(i_k) * math.sin(Omega_k)
Y = x_k_prime * math.sin(Omega_k) + y_k_prime * math.cos(i_k) * math.cos(Omega_k)
Z = y_k_prime * math.sin(i_k)
```
**🎯 结果 `(X, Y, Z)` 即为时间 `t` 时卫星在 ECEF 坐标系中的位置。**

---

## 🧪 代码示例 (Python)

```python
import math

# 定义地球常数
GM = 3.9860050e14
OMEGA_DOT_E = 7.2921151467e-5

def compute_sat_pos(ephemeris, t):
    """
    根据给定的广播星历和GPS时间，计算ECEF坐标系下的卫星位置(X, Y, Z)。
    参数:
        ephemeris: 包含所有广播星历参数的字典。
        t: GPS周内秒 (seconds).
    返回:
        (X, Y, Z): ECEF坐标，单位米。
    """
    # --- 提取参数 (确保单位已从半圆转换为弧度) ---
    # ... (代码用于提取 e, sqrtA, M0, Omega0, i0, omega, Delta_n, IDOT, OmegaDot,
    #      Cuc, Cus, Crc, Crs, Cic, Cis, toe)
    # 例如: M0 = ephemeris['M0'] * math.pi

    # --- 步骤 1: 计算相对于星历参考时刻的时间差 ---
    t_k = t - ephemeris['toe']
    if t_k > 302400:
        t_k -= 604800
    elif t_k < -302400:
        t_k += 604800

    # --- 步骤 2: 计算校正后的平均角速度 ---
    A = (ephemeris['sqrtA'])**2
    n0 = math.sqrt(GM / A**3)
    n = n0 + ephemeris['Delta_n']

    # --- 步骤 3: 计算平近点角 ---
    M_k = ephemeris['M0'] + n * t_k

    # --- 步骤 4: 迭代求解偏近点角 (调用函数) ---
    E_k = solve_kepler(M_k, ephemeris['e'])

    # --- 步骤 5: 计算真近点角 ---
    sin_nu = (math.sqrt(1 - ephemeris['e']**2) * math.sin(E_k)) / (1 - ephemeris['e'] * math.cos(E_k))
    cos_nu = (math.cos(E_k) - ephemeris['e']) / (1 - ephemeris['e'] * math.cos(E_k))
    nu_k = math.atan2(sin_nu, cos_nu)

    # --- 步骤 6 & 7: 计算并应用摄动修正 ---
    Phi_k = nu_k + ephemeris['omega']
    delta_u = ephemeris['Cus'] * math.sin(2*Phi_k) + ephemeris['Cuc'] * math.cos(2*Phi_k)
    delta_r = ephemeris['Crs'] * math.sin(2*Phi_k) + ephemeris['Crc'] * math.cos(2*Phi_k)
    delta_i = ephemeris['Cis'] * math.sin(2*Phi_k) + ephemeris['Cic'] * math.cos(2*Phi_k)

    u_k = Phi_k + delta_u
    r_k = A * (1 - ephemeris['e'] * math.cos(E_k)) + delta_r
    i_k = ephemeris['i0'] + ephemeris['IDOT'] * t_k + delta_i

    # --- 步骤 8: 计算在轨道平面内的位置 ---
    x_prime = r_k * math.cos(u_k)
    y_prime = r_k * math.sin(u_k)

    # --- 步骤 9: 转换到ECEF坐标系 ---
    Omega_k = ephemeris['Omega0'] + (ephemeris['OmegaDot'] - OMEGA_DOT_E) * t_k - OMEGA_DOT_E * ephemeris['toe']
    X = x_prime * math.cos(Omega_k) - y_prime * math.cos(i_k) * math.sin(Omega_k)
    Y = x_prime * math.sin(Omega_k) + y_prime * math.cos(i_k) * math.cos(Omega_k)
    Z = y_prime * math.sin(i_k)

    return (X, Y, Z)

def solve_kepler(M, e, tolerance=1e-12, max_iter=10):
    """ 使用牛顿-拉弗森法求解开普勒方程 """
    E = M  # 初始猜测
    for _ in range(max_iter):
        delta_E = (M - (E - e * math.sin(E))) / (1 - e * math.cos(E))
        E += delta_E
        if abs(delta_E) < tolerance:
            break
    return E
```

---

## ⚠️ 重要注意事项

- **🗓️ 周内秒翻转 (WNRO)：** 始终检查 `t_k` (GPS周内秒) 是否需要通过 ± 604800 秒进行调整，以确保其在与参考时间 `t_oe` 相差一周的范围内。
- **🧮 单位转换：** 这是最常见的错误来源。**确保导航电文中的所有角度参数（例如 `M0`, `omega`, `Omega0`, `i0`）都已从半圆转换为弧度。**
- **⏰ 星历有效性：** 广播星历的有效期通常为 `t_oe` 前后 2-4 小时。在此时间窗口之外使用会导致计算精度迅速下降。
- **🎯 精度：** 基于广播星历计算的位置预期精度约为 **~1-2 米 (RMS)**。对于更高精度（厘米级），必须使用事后处理的**精密星历**文件。
- **🔄 地球自转修正 (萨格纳克效应)：** 计算得到的位置 `(X, Y, Z)` 在**信号发射时刻** `t_{sv}` 是有效的。对于极高保真度的仿真，可能需要将卫星位置旋转一个角度，以修正信号传播过程中地球自转的影响。这通常在单独的通道模型中处理。

---

## 🔚 结论

卫星位置计算算法是一个确定性的过程，它将开普勒参数和摄动项转换为精确的 ECEF 坐标。掌握该算法对于从事 GNSS 信号仿真、接收机设计或高精度定位的任何人来说都至关重要。

---

## 📚 参考资料

1.  IS-GPS-200, Navstar GPS 空间段/导航用户段接口文件
2.  欧洲 GNSS (Galileo) 开放服务空间信号接口控制文件 (OS SIS ICD)
3.  北斗卫星导航系统空间信号接口控制文件公开服务信号B1I (版本 3.0)
4.  **Hofmann-Wellenhof, B., Lichtenegger, H., & Wasle, E. (2007). *GNSS - Global Navigation Satellite Systems.* Springer-Verlag Wien.** - 该领域的权威教科书。

<p align="center">
  <sub>为 GNSS 而做，倾注了 📡 与 ❤️ </sub>
</p>
